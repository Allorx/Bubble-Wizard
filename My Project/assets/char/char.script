local velocity_addition = 25
local velocity = 0
local tap_delay = 0.2

function init(self)
	msg.post(".", "acquire_input_focus")
	-- for 3d rendering
	msg.post("@render:", "use_camera_projection")
	msg.post("camera", "acquire_camera_focus")

	self.can_touch = true
	self.friction = 0.1
	self.velocity_mult = 1.8
end

function update(self, dt)
	rotate(".", rotation() + velocity * dt)
	velocity = velocity*(1-self.friction)
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and self.can_touch == true then
		-- !!!!! 960 is the same width as in game.project - must be same
		-- check if held
		if action.pressed then
			self.pressed_time = socket.gettime()
		elseif action.released then
			if (socket.gettime() - self.pressed_time) > tap_delay then
				-- held
				print("held")
			else
				--tapped
				if action.x < 960/2 then
					-- rotate left
					velocity = (velocity-velocity_addition)*self.velocity_mult
				else
					-- rotate right
					velocity = (velocity+velocity_addition)*self.velocity_mult
				end
			end
		end
	end
end

-- rotate & rotation function from: https://forum.defold.com/t/simple-rotation-and-facing/65681
function rotate(from, to)
	if tonumber(to) then
		if to == nil then
			to = go.get_id()
		end
		go.set(from, "euler.y", to)
	else
		local direction = go.get_position(to) - go.get_position(from)
		local rotation = vmath.quat_rotation_z(math.atan2(direction.y, direction.x))
		go.set_rotation(rotation, from)
	end
end

function rotation(url)
	return go.get(url or ".", "euler.y")
end


--[[
function anim_complete(self)
	-- spawn stuff
	create_object(self)
	create_stair(self)
	self.can_touch = true
end

function create_stair(self)
	factory.create(stair, go.get_position("#char"), go.get_rotation("#char"), nil, self.stair_scale)
end

function create_object(self)
	if self.created_buff == true then
		msg.post("/object_spawner", "create_enemy")
		self.created_buff = false
	elseif self.created_buff == false then
		msg.post("/object_spawner", "create_buff")
		self.created_buff = true
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trigger_response") then
		if message.enter then
			solve_collision(self, message)
		else
			-- on trigger exit
		end
	end
end

function solve_collision(self, message)
	-- react to collision
	if message.other_group == hash("buff") then
		-- buff collision
		print("I collided with", message.other_group)
	elseif message.other_group == hash("enemy") then
		-- enemy collision
		print("I collided with", message.other_group)
	end
end
]]--